# Comprehensive RISC-V CPU Simulator Test Program
# Tests all implemented instructions with expected outputs

# Initialize registers with test values
    0:        00100293        addi x5 x0 1        # t0 = 1
    4:        00200313        addi x6 x0 2        # t1 = 2
    8:        00300393        addi x7 x0 3        # t2 = 3
    c:        00400413        addi x8 x0 4        # s0 = 4
    10:        00500493        addi x9 x0 5        # s1 = 5

# R-type arithmetic instructions
    14:        00628333        add x6 x5 x6        # t1 = t0 + t1 = 1 + 2 = 3
    18:        406303b3        sub x7 x6 x6        # t2 = t1 - t1 = 3 - 3 = 0
    1c:        00740433        add x8 x8 x7        # s0 = s0 + t2 = 4 + 0 = 4

# R-type logical instructions
    20:        0064e4b3        or x9 x9 x6         # s1 = s1 | t1 = 5 | 3 = 7
    24:        0064c4b3        xor x9 x9 x6        # s1 = s1 ^ t1 = 7 ^ 3 = 4
    28:        0064f4b3        and x9 x9 x6        # s1 = s1 & t1 = 4 & 3 = 0

# R-type shift instructions
    2c:        0014c4b3        srl x9 x9 x1        # s1 = s1 >> 1 = 0 >> 1 = 0
    30:        0014a4b3        sll x9 x9 x1        # s1 = s1 << 1 = 0 << 1 = 0
    34:        4014c4b3        sra x9 x9 x1        # s1 = s1 >> 1 = 0 >> 1 = 0

# R-type comparison instructions
    38:        0064a4b3        slt x9 x9 x6        # s1 = (s1 < t1) ? 1 : 0 = (0 < 3) ? 1 : 0 = 1
    3c:        0064b4b3        sltu x9 x9 x6       # s1 = (s1 < t1) ? 1 : 0 = (0 < 3) ? 1 : 0 = 1

# I-type arithmetic instructions
    40:        00628293        addi x5 x5 6        # t0 = t0 + 6 = 1 + 6 = 7
    44:        00730313        addi x6 x6 7        # t1 = t1 + 7 = 3 + 7 = 10

# I-type logical instructions
    48:        00f4e493        ori x9 x9 15        # s1 = s1 | 15 = 1 | 15 = 15
    4c:        00f4c493        xori x9 x9 15       # s1 = s1 ^ 15 = 15 ^ 15 = 0
    50:        00f4f493        andi x9 x9 15       # s1 = s1 & 15 = 0 & 15 = 0

# I-type shift instructions
    54:        0024d493        srli x9 x9 2        # s1 = s1 >> 2 = 0 >> 2 = 0
    58:        00249493        slli x9 x9 2        # s1 = s1 << 2 = 0 << 2 = 0
    5c:        4024d493        srai x9 x9 2        # s1 = s1 >> 2 = 0 >> 2 = 0

# I-type comparison instructions
    60:        0064a493        slti x9 x9 6        # s1 = (s1 < 6) ? 1 : 0 = (0 < 6) ? 1 : 0 = 1
    64:        0064b493        sltiu x9 x9 6       # s1 = (s1 < 6) ? 1 : 0 = (0 < 6) ? 1 : 0 = 1

# Load/Store instructions
    68:        00002023        sw x0 0 x0          # Store 0 at memory address 0
    6c:        00502223        sw x5 4 x0          # Store t0 (7) at memory address 4
    70:        00602423        sw x6 8 x0          # Store t1 (10) at memory address 8
    74:        00002503        lw x10 0 x0         # Load from address 0 to a0
    78:        00402583        lw x11 4 x0         # Load from address 4 to a1
    7c:        00802603        lw x12 8 x0         # Load from address 8 to a2

# Branch instructions (conditional)
    80:        00648063        beq x9 x6 0         # Branch if s1 == t1 (1 == 10) = false, no branch
    84:        0064a263        beq x9 x6 4         # Branch if s1 == t1 (1 == 10) = false, no branch
    88:        00649463        bne x9 x6 8         # Branch if s1 != t1 (1 != 10) = true, branch
    8c:        0064a663        beq x9 x6 12        # This should not execute due to branch above
    90:        0064b863        bne x9 x6 16        # This should not execute due to branch above

# Jump instructions
    94:        0100006f        jal x0 16           # Jump forward 16 bytes
    98:        0064a063        beq x9 x6 0         # This should not execute due to jump above
    9c:        0064a263        beq x9 x6 4         # This should not execute due to jump above

#end

# M Extension - Multiply/Divide instructions
# Setup: t0 = 7, t1 = 10, t2 = 0, s0 = 4, s1 = 1
    a0:        023283b3        mul x7 x5 x6         # t2 = t0 * t1 = 7 * 10 = 70
    a4:        0232a3b3        mulh x7 x5 x6         # t2 = (t0 * t1) >> 32 (signed) = (7 * 10) >> 32 = 0
    a8:        0232b3b3        mulhsu x7 x5 x6       # t2 = (t0 * t1) >> 32 (signed-unsigned) = 0
    ac:        0232c3b3        mulhu x7 x5 x6        # t2 = (t0 * t1) >> 32 (unsigned) = 0
    b0:        0232e3b3        div x7 x5 x6          # t2 = t0 / t1 = 7 / 10 = 0 (integer division)
    b4:        0232f3b3        divu x7 x5 x6         # t2 = t0 / t1 (unsigned) = 7 / 10 = 0
    b8:        0262e3b3        rem x7 x5 x6          # t2 = t0 % t1 = 7 % 10 = 7
    bc:        023313b3        remu x7 x5 x6         # t2 = t0 % t1 (unsigned) = 7 % 10 = 7

# M Extension - Test with larger values
    c0:        00a00293        addi x5 x0 10         # t0 = 10
    c4:        00300313        addi x6 x0 3          # t1 = 3
    c8:        023283b3        mul x7 x5 x6          # t2 = t0 * t1 = 10 * 3 = 30
    cc:        0232e3b3        div x7 x5 x6          # t2 = t0 / t1 = 10 / 3 = 3
    d0:        0262e3b3        rem x7 x5 x6          # t2 = t0 % t1 = 10 % 3 = 1

# C Extension - Compressed instructions (16-bit)
# Setup: t0 = 10, t1 = 3, t2 = 1, s0 = 4, s1 = 1
    d4:        0501                c.addi x10 0          # a0 = a0 + 0 = 0 (no change, test C.ADDI)
    d6:        0525                c.addi x10 5          # a0 = a0 + 5 = 5
    d8:        4501                c.li x10 0            # a0 = 0 (load immediate)
    da:        4515                c.li x10 5            # a0 = 5 (load immediate)
    dc:        06a1                c.addi x13 8           # a3 = a3 + 8 (if a3=0, then a3=8)
    de:        06ad                c.addi x13 11         # a3 = a3 + 11 = 8 + 11 = 19
    e0:        800d                c.srli x8 3           # s0 = s0 >> 3 (x8 = s0/fp)
    e2:        8411                c.srai x8 4           # s0 = s0 >> 4 (arithmetic)
    e4:        8831                c.andi x8 12          # s0 = s0 & 12
    e6:        8c89                c.sub x9 x10          # s1 = s1 - a0 (changed to use x8-x15 range)
    e8:        9ca9                c.xor x9 x10          # s1 = s1 ^ a0
    ea:        9ccd                c.or x9 x10           # s1 = s1 | a0
    ec:        9c89                c.and x9 x10        # s1 = s1 & a0
    ee:        c222                c.swsp x8 8           # Store s0 (4) at sp+8
    f0:        4502                c.lwsp x10 0          # Load from sp+0 to a0
    f2:        d40a                c.sw x13 8 x8        # Store a3 at s0+8 (if s0=4, then address 12)
    f4:        4014                c.lw x13 0 x8         # Load from s0+0 (address 4) to a3
    f6:        94b6                c.add x9 x13        # s1 = s1 + a3
    f8:        84b6                c.mv x9 x13          # s1 = a3 (move)
    fa:        8082                c.jr x1                # Jump to address in ra (return)
    fc:        9502                c.jalr x10            # Jump and link to address in a0
    fe:        a009                c.j 2                 # Jump forward 2 bytes (to 0x100)
   100:        e011                c.bnez x8 4           # Branch if s0 != 0 (s0=4, so branch taken)
   102:        8e85                c.add x9 x28         # This should not execute (skipped by branch)
   104:        c009                c.beqz x8 2            # Branch if s0 == 0 (s0=4, so branch not taken)
   106:        8e85                c.add x9 x28         # This should execute (branch not taken)

# Expected final register values:
# a0 = 0 (from C.LWSP or previous value)
# a1 = 7 (loaded from memory[4]) 
# a2 = 10 (loaded from memory[8])
# t0 = 10 (updated in M extension tests)
# t1 = 3 (updated in M extension tests)
# t2 = 1 (from rem 10 % 3)
# a3 = 7 (from C.LW loading memory[4])
# t4 = 7 (from C.MV t3)
# s0 = 4
# s1 = 1 